# Final Project Report

### Main Functions + Output Details
Given the setup of our graph, the main functions of our data was of our data was split up into 4 different sections: 1) Constructor (building the graph itself from the parsed data, 2) Tarjan’s algorithm to find strongly connected components, 3) Route Connections (a function that uses DFS to check the connection of two stops on a route), and 4) Prim’s to return a minimum spanning tree for the graph to find efficient paths from a stop to all the other stops within the graph. For the output, we return respectively: 1) the set up of the graph itself, which was represented with an adjacency list, 2) a low-linked map that provides group numbers that represent the strongly connected components (stops) within the bus system, 3) printed responses that shows if two stops are connected on a specific route, and 4) a minimum spanning tree given one stop on the graph to show the best paths from it to each of the other stops (assuming that the other stops are being visited). 

### Results Details
For the results, due to the size of our data, we evaluated smaller subsets of it to better understand the data. For the Route Connection function, the algorithm output was especially large, so a bit large so we ran it on a smaller subset of our data to check the connections between some of the stops. In doing so, we found that the output indicates that we can successfully identify which stops of the bus system are connected by a particular route. We have a large output file that contains a lot of our data (a full file checking connections for every stop to each other on every route is both inefficient to produce and evaluate). As such, we also have a smaller, more readable one that mimics what users would actually apply our program to. For our Tarjan's algorithm, we described the output by printing out the low-linked values for each vertex, which demonstrates the connected components. We found that the majority of the components are considered "strongly connected", which makes sense due to the interconnectivity of the bus system especially with there being many popular stops. It would be nice to have a way to intensify the "strength" of the component connection. For Prim's algorithm, the intention was to pick an arbitrary starting node, picking the smallest edge and adding it to the tree, and keep picking the smallest accessible edge until a minimum spanning tree has been generated. When we tried to generate a minimum spanning tree using Prim's, on one of our test cases (a larger scale one), the graph outputted consisted of two disjoint trees that did have minimum edge weights, but were nonetheless not connected, hence not a minimum spanning tree. The issue arose from not picking the next edge properly, as the edge chosen was not always accessible from the current tree at that point. Finding a way to fix this should yield a minimum spanning tree that works for the dataset that we have.

### Testing
For the build of the graph itself, the output is just a printed out version of our adjacency list. The build of this was initially tested with our example dataset files, which printed out the connections between the vertices to check whether or not they lined up with our expectations. It is also tested in most of our test cases, since before the test cases run the algorithm they’re testing, they first build a graph by parsing the example dataset that we run. It should be noted for all of our test cases that we tested them on smaller graphs in order to confirm the functionality of the code. This was because checking the results for such a large scale dataset would’ve been nearly impossible to confirm. For Tarjan’s algorithm, we have several test cases that take in different graphs of varying levels of complexing, which we then check for its strongly connected components and if that output is correct. A similar process was approached for Route connection, where we represented a graph with different routes between a set of points and checked the connectivity of points for each of these routes, including edge cases. The same approach was used where the Prim's algorithm was run on our example datasets and then we checked the minimum spanning tree that it returned. 

### Leading Question/Goals
Our overarching question that our project focused on was what useful information can we add or provide to users who use the system. We had initially split this into 3 main sub questions, a) how can we find the shortest path that is also the cheapest (for people who use this system off campus, as buses off campus require money) b) how can we find which areas are strongly connected, because this can provide different options to reach a certain stop and 3) how can we find which stops are connected on a specific route. Some of these questions changed over time given the details of the bus system itself. The first subquestion changed the most, since evaluating how the costs in the bus system works, we learned that the cost works not off of the number of stops traveled or distance but simply by the number of buses taken, as well as if the passenger gets on the bus off campus. With this information, we realized that it would not be productive to try and measure cost. As a result, we decided to find the quickest path instead. Our other two goals to address our overarching question remained the same. With our new subquestions, we were successful in being able to our leading question by being able to calculate paths 


### Question Answers/Discoveries
Due to the size of our dataset, we had to evaluate results in subsets and details to find answers since there was too much data to make conclusions about all the overarching trends. For the Prim's algorithm, most descriptions rely on the vertices being ordered in some way, but our vertices were labelled with string names, which can't be easily compared in a way that makes sense. Finding a good way to either order our vertices, or find an efficient method to find the next smallest connected edge will make Prim's work properly on our dataset. Our next attempt at implementing Prim's algorithm would involve maintaining an ordered set (an unordered set would require a user-defined hash function) of edges that are currently accessible, and iterating through the whole thing each time we add an edge to the tree, which might not be the fastest solution, but seems like the only possible solution in our case. In trying to find which areas and stops are strongly connected, we found that overall within our bus system there were many stops that were considered to be within one main strongly connected component, while a handful of others were considered strongly connected only to itself. This makes sense within the context of our bus systems since there often is a main route that is strongly connected, with occasional less popular stops. When looking at the subset of different routes, we found that our method for finding stops that were connected on one route was indeed successful.This information provides users different information that they can utilize. This includes finding the quickest way to get from one stop to the next. It also includes different options of getting between stops if they’re strongly connected, like if a user is at one stop and they need to get another, but they missed a route that takes one path. Using strongly connected components shows a different way they could get to their destination. We can also provide users a way to check if they can get to their destination using a specific bus route. All of these pieces can be utilized to improve the utility of the bus system for MTD users. 
